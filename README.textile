h1. Impresario

A light weight workflow, or state machine library in Clojure.

h1. What is a Workflow?

There are many implementations of workflow systems in many languages.  There are even standard workflow definitions and systmes (BPEL, XPDL).  This implementation takes inspiration from those implementations.  Impresario is not attempting to be any of those.  I needed to model a conversation with a 'bot' and needed a simple, light weight workflow system that was easy for me to use, easy to serialize and followed the lead of Clojure's immutable data structures.

Impresario workflows are state machines.  Workflows declare a graph with nodes (states), vertexes (transitions), and observers of those nodes and vertexes (trigger conditions).  Workflows are implemented as an immutable Clojure map.  Current state is modeled as a keyword.  The context, or state, for the workflow is also modeled as an immutable map (the default).

A workflow may have one and only one start state (maked with @:start@).  Terminal states must be marked with a @:stop@.

!blob/master/examples/simple-workflow.dot.png!


<pre class="code">
{:name :simple-workflow
   :states
   {:first-state
    {:start true
     :transitions
     [{:state :next-state
       :if :impresario.test.core/transition-every-time}]}
    :next-state
    {:transitions
     [{:state :final-state
       :if :impresario.test.core/transition-every-time}]}
    :final-state
    {:transitions []}}}
</pre>

h1. Transitioning Between States and Context

Transition predicates (@:if@ and @:unless@) are used to determine if, from a given state with a given context a specific edge can be followed.  These predicates are given access to the context, and should not modify it - only to return true or false indicating if the edge should be followed.

You can test the workflow to see if a transition would take place by invoking @transition-once?@ to see if at least 1 transition can be made, or @transition?@ to see how far the workflow would transition with a given context.  Note that this may not be the same path taken during action transitioning as the trigger functions are there specifically so the context can be modified.  Doing so may alter the path identified by the predicate functions.  In practice, this is up to the implementor of the workflow to decited how they want their predicates and triggers to interact.

h1. Triggers

Triggers are executed when @transition-once!@ and @transition!@ are used to step the workflow forward.  Triggers return the new context, and thus have the ability to return a new context (derived from the previous context).

There are a few supported types of triggers:

* a single trigger for on _any_ transition
* on entry into a specific state
* when a specific edge is followed
* on exit from a specific state

Triggers must be declared within the workflow as Clojure keywords, triggers may be a single keyword or a seq of keywords.   When a transition is taking place, the 'exit' triggers are invoked first - indicating that the previous state is being left.   The transition's triggers are then executed, followed by the 'on enter' triggers for the new state.

Each of these triggers must return the state that will be passed to the next trigger, as well as be returned from the transition function.

h2. Global @:on-transition@

A workflow wide @:on-transition@ trigger may be declared.  This observer is executed after the on-exit triggers have been fired for a state, but before any edge specific on-transition triggers are invoked.

h2. External Triggers

_unfinished section_

Waking up a workflow.  External actors make trigger or awaken a workflow providing new state information for the workflow so that it may make another transition.

h2. Serialiation

h3. Recommended Data Model

Two tables:

h4. WORKFLOW_DEFINITIONS

  id integer
  name varchar(255)
  version interter
  definition text

h4. WORKFLOW_INSTANCES

  id integer
  workflow_id integer fk to workflow_definitions
  internal_state text
  external_state text


h1. Future Work

h3. global exception state

A declared state, with possible transition's out, but no explicit edges leading in.  If any predicate or trigger throws an exception, this state is entered.  This gives the exception state the ability to handle errors and transition to one of the other states - or abort the workflow completely (by re-raising the exception).

h3. Timeouts

Each node should have the ability to declare a particular edge to be followed after some amount of time has elapsed.

Workflows should support a 'global' timeout.  If the workflow has not transitioned (or been woken up) in the declared time span, it should cause an exception within the workflow.  This allows workflow instances to be expired, discarded, etc.


